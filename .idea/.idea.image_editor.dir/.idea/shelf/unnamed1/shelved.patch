Index: image_editor/src/image_editor/layers/layers.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use cgmath::{Point2, Point3, Vector2};\nuse framework::framework::TextureId;\nuse framework::renderer::renderer::Renderer;\nuse framework::scene::Transform2d;\nuse framework::{framework::BufferId, BufferConfiguration, Framework, MeshInstance2D};\n\nuse super::{bitmap_layer, BitmapLayer};\n\n#[derive(Clone, PartialEq)]\npub struct LayerSettings {\n    pub name: String,\n    pub is_enabled: bool,\n    pub opacity: f32,\n}\n\n#[repr(C)]\n#[derive(Clone, Copy, PartialEq, bytemuck::Zeroable, bytemuck::Pod)]\npub struct ShaderLayerSettings {\n    pub opacity: f32,\n}\n\npub struct Layer<'framework> {\n    framework: &'framework Framework,\n    pub bitmap: BitmapLayer,\n    pub settings: LayerSettings,\n    pub layer_type: LayerType,\n    pub position: Point2<f32>,\n    pub scale: Vector2<f32>,\n    pub rotation_radians: f32,\n    pub instance_buffer_id: BufferId,\n}\n\npub struct LayerCreationInfo {\n    pub name: String,\n    pub position: Point2<f32>,\n    pub scale: Vector2<f32>,\n    pub rotation_radians: f32,\n}\n\npub enum LayerType {\n    Bitmap,\n}\n\nimpl<'framework> Layer<'framework> {\n    pub fn new_bitmap(\n        bitmap: BitmapLayer,\n        creation_info: LayerCreationInfo,\n        framework: &'framework Framework,\n    ) -> Self {\n        let instance_buffer_id = framework.allocate_typed_buffer(BufferConfiguration {\n            initial_setup: framework::buffer::BufferInitialSetup::Data(\n                &Vec::<MeshInstance2D>::new(),\n            ),\n            buffer_type: framework::BufferType::Vertex,\n            allow_write: true,\n            allow_read: false,\n        });\n\n        Self {\n            framework,\n            bitmap,\n            settings: LayerSettings {\n                name: creation_info.name,\n                is_enabled: true,\n                opacity: 1.0,\n            },\n            layer_type: LayerType::Bitmap,\n            position: creation_info.position,\n            scale: creation_info.scale,\n            rotation_radians: creation_info.rotation_radians,\n            instance_buffer_id,\n        }\n    }\n\n    fn wgpu_color(&self) -> wgpu::Color {\n        wgpu::Color {\n            r: 1.0,\n            g: 1.0,\n            b: 1.0,\n            a: self.settings.opacity as f64,\n        }\n    }\n\n    pub(crate) fn update(&mut self, framework: &Framework) {\n        \n    }\n    pub(crate) fn draw<'library, 'pass, 'l>(&'l self, renderer: &mut Renderer, target: &TextureId, shader_to_use: ShaderId)\n    where\n        'framework: 'pass,\n        'l: 'pass,\n    {\n        if !self.settings.is_enabled {\n            return;\n        }\n        match &self.layer_type {\n            LayerType::Bitmap => {\n                self.bitmap.draw(\n                    renderer,\n                    self.position,\n                    self.scale,\n                    self.rotation_radians,\n                    self.settings.opacity,\n                    target,\n                );\n            }\n        }\n    }\n\n    pub fn settings(&self) -> LayerSettings {\n        self.settings.clone()\n    }\n\n    pub fn set_settings(&mut self, new_settings: LayerSettings) {\n        self.settings = new_settings;\n\n        self.framework.buffer_write_sync(\n            &self.instance_buffer_id,\n            vec![MeshInstance2D::new(\n                self.position,\n                self.scale,\n                self.rotation_radians,\n                true,\n                wgpu::Color::WHITE,\n            )],\n        );\n    }\n\n    pub fn transform(&self) -> Transform2d {\n        Transform2d {\n            position: Point3 {\n                x: self.position.x,\n                y: self.position.y,\n                z: 0.0,\n            },\n            scale: Vector2 {\n                x: self.scale.x,\n                y: self.scale.y,\n            },\n            rotation_radians: cgmath::Rad(self.rotation_radians),\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/image_editor/src/image_editor/layers/layers.rs b/image_editor/src/image_editor/layers/layers.rs
--- a/image_editor/src/image_editor/layers/layers.rs	(revision bc6ee0c8c0a2a85724e6e6e7122f5b40699e5012)
+++ b/image_editor/src/image_editor/layers/layers.rs	(date 1665954472972)
@@ -1,5 +1,5 @@
 use cgmath::{Point2, Point3, Vector2};
-use framework::framework::TextureId;
+use framework::framework::{ShaderId, TextureId};
 use framework::renderer::renderer::Renderer;
 use framework::scene::Transform2d;
 use framework::{framework::BufferId, BufferConfiguration, Framework, MeshInstance2D};
@@ -101,6 +101,7 @@
                     self.rotation_radians,
                     self.settings.opacity,
                     target,
+                    Some(shader_to_use)
                 );
             }
         }
Index: image_editor/src/image_editor/layers/layer_fragment.wgsl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/image_editor/src/image_editor/layers/layer_fragment.wgsl b/image_editor/src/image_editor/layers/layer_fragment.wgsl
new file mode 100644
--- /dev/null	(date 1665953555846)
+++ b/image_editor/src/image_editor/layers/layer_fragment.wgsl	(date 1665953555846)
@@ -0,0 +1,38 @@
+//@include :common_definitions
+//@include :2d_definitions
+//@include :blend_modes
+
+struct BlendSettings {
+    blend_mode: i32,
+    // x, y, w, h
+    source_rect: vec4<f32>,
+    dest_rect: vec4<f32>
+}
+
+@group(2) @binding(0) var top: texture_2d<f32>;
+@group(2) @binding(1) var s_top: sampler;
+
+@group(3) @binding(0) var bottom: texture_2d<f32>;
+@group(3) @binding(1) var s_bottom: sampler;
+
+@group(4) @binding(0) var<uniform> blend_settings: BlendSettings;
+
+fn compute_dest_uv(settings: BlendeSettings, source_uv: vec2<f32>) -> vec2<f32> {
+    let source_location = vec2<f32>(settings.source_rect.x, settings.source_rect.y);
+    let source_size = vec2<f32>(settings.source_rect.w, settings.source_rect.z);
+    let dest_location = vec2<f32>(settings.dest_rect.x, settings.dest_rect.y);
+    let dest_size = vec2<f32>(settings.dest_rect.w, settings.dest_rect.z);
+    
+    let source_uv_to_fragment_pos = source_location + vec2<f32>(source_size.x * source_uv.x, source_size.y * source_uv.y);
+    let uv_into_dest_rect = vec2<f32>(source_uv_to_fragment_pos.x / (dest_size.x + dest_location.x), source_uv_to_fragment_pos.x / (dest_size.y + dest_location.y));
+    return uv_into_dest_rect;
+}
+
+@fragment
+fn fragment(in: FragmentInput) -> @location(0) vec4<f32> {
+    let bottom_uv = compute_dest_uv(blend_settings, in.tex_uv);
+    let top_sample = textureSample(top, s_top, in.tex_uv);
+    let bottom_sample = textureSample(bottom, s_bottom, bottom_uv);
+    let color = select_blend_mode(BLEND_NORMAL, bottom_sample, top_sample);
+    return color.a * in.multiply_color;
+}
\ No newline at end of file
Index: app/src/main.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>mod app_state;\r\npub mod input_state;\r\nmod toolbox;\r\npub mod tools;\r\nmod ui;\r\n\r\nuse app_state::ImageApplication;\r\nuse framework::Framework;\r\npub use input_state::key::*;\r\npub use input_state::*;\r\nuse tools::*;\r\n\r\nuse winit::dpi::PhysicalSize;\r\n\r\nasync fn run_app() -> anyhow::Result<()> {\r\n    let event_loop = winit::event_loop::EventLoop::new();\r\n    let window = winit::window::WindowBuilder::new()\r\n        .with_title(\"Image editor\")\r\n        .with_min_inner_size(PhysicalSize {\r\n            width: 800,\r\n            height: 600,\r\n        })\r\n        .build(&event_loop)?;\r\n\r\n    let framework = Box::leak(Box::new({\r\n        let framework = Framework::new(&wgpu::DeviceDescriptor {\r\n            label: Some(\"Image Editor framework\"),\r\n            features: wgpu::Features::empty(),\r\n            limits: wgpu::Limits::downlevel_defaults(),\r\n        });\r\n\r\n        match framework {\r\n            Ok(framework) => {\r\n                framework.log_info();\r\n                framework\r\n            }\r\n            Err(e) => {\r\n                panic!(\"Error while creating framework: {}\", e)\r\n            }\r\n        }\r\n    }));\r\n    let app_state = Box::leak(Box::new(ImageApplication::new(window, framework)));\r\n\r\n    event_loop.run(move |event, _, control_flow| {\r\n        *control_flow = app_state.on_event(&event);\r\n    });\r\n}\r\n\r\nfn main() {\r\n    env_logger::init();\r\n\r\n    let result = pollster::block_on(run_app());\r\n    match result {\r\n        Ok(()) => {}\r\n        Err(e) => panic!(\"Error while running application: {e}\"),\r\n    };\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main.rs b/app/src/main.rs
--- a/app/src/main.rs	(revision ff7293a213d38a846165f08c5adac7ae94ee7857)
+++ b/app/src/main.rs	(date 1665948427567)
@@ -22,7 +22,7 @@
         })
         .build(&event_loop)?;
 
-    let framework = Box::leak(Box::new({
+    let mut framework = Box::leak(Box::new({
         let framework = Framework::new(&wgpu::DeviceDescriptor {
             label: Some("Image Editor framework"),
             features: wgpu::Features::empty(),
@@ -39,6 +39,7 @@
             }
         }
     }));
+    framework.shader_compiler.define("blend_modes", include_str!("blend_modes.wgsl")).unwrap();
     let app_state = Box::leak(Box::new(ImageApplication::new(window, framework)));
 
     event_loop.run(move |event, _, control_flow| {
Index: image_editor/src/image_editor/layers/bitmap_layer.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use cgmath::{num_traits::ToPrimitive, Point3, Rad, Vector2};\r\nuse framework::{\r\n    framework::TextureId,\r\n    renderer::{\r\n        draw_command::{DrawCommand, DrawMode, OptionalDrawData, PrimitiveType},\r\n        renderer::Renderer,\r\n    },\r\n    Camera2d, Framework, MeshInstance2D, Texture2dConfiguration, Transform2d,\r\n};\r\n\r\npub struct BitmapLayerConfiguration {\r\n    pub label: String,\r\n    pub width: u32,\r\n    pub initial_background_color: [f32; 4],\r\n    pub height: u32,\r\n}\r\npub struct BitmapLayer {\r\n    texture: TextureId,\r\n    configuration: BitmapLayerConfiguration,\r\n}\r\n\r\nimpl BitmapLayer {\r\n    pub fn new(framework: &Framework, configuration: BitmapLayerConfiguration) -> Self {\r\n        let bytes: Vec<u32> = (1..(configuration.width * configuration.height) + 1)\r\n            .map(|_| {\r\n                let bg = configuration.initial_background_color;\r\n                let r = (bg[0].clamp(0.0, 1.0) * 255.0).to_u8().unwrap();\r\n                let g = (bg[1].clamp(0.0, 1.0) * 255.0).to_u8().unwrap();\r\n                let b = (bg[2].clamp(0.0, 1.0) * 255.0).to_u8().unwrap();\r\n                let a = (bg[3].clamp(0.0, 1.0) * 255.0).to_u8().unwrap();\r\n                u32::from_le_bytes([r, g, b, a])\r\n            })\r\n            .collect();\r\n        let bytes = bytemuck::cast_slice(&bytes);\r\n        Self::new_from_bytes(framework, &bytes, configuration)\r\n    }\r\n\r\n    pub fn new_from_bytes(\r\n        framework: &Framework,\r\n        bytes: &[u8],\r\n        configuration: BitmapLayerConfiguration,\r\n    ) -> Self {\r\n        let format = wgpu::TextureFormat::Rgba8UnormSrgb;\r\n\r\n        let texture = framework.allocate_texture2d(\r\n            Texture2dConfiguration {\r\n                debug_name: Some(configuration.label.clone() + \" Texture\"),\r\n                width: configuration.width,\r\n                height: configuration.height,\r\n                format,\r\n                allow_cpu_write: true,\r\n                allow_cpu_read: true,\r\n                allow_use_as_render_target: true,\r\n            },\r\n            Some(bytes),\r\n        );\r\n\r\n        Self {\r\n            texture,\r\n            configuration,\r\n        }\r\n    }\r\n\r\n    pub fn texture(&self) -> &TextureId {\r\n        &self.texture\r\n    }\r\n\r\n    pub fn size(&self) -> Vector2<f32> {\r\n        Vector2 {\r\n            x: self.configuration.width as f32,\r\n            y: self.configuration.height as f32,\r\n        }\r\n    }\r\n\r\n    pub fn replace_texture(&mut self, new_texture: TextureId) {\r\n        self.texture = new_texture\r\n    }\r\n\r\n    pub fn draw(\r\n        &self,\r\n        renderer: &mut Renderer,\r\n        position: cgmath::Point2<f32>,\r\n        scale: Vector2<f32>,\r\n        rotation_radians: f32,\r\n        opacity: f32,\r\n        output: &TextureId,\r\n    ) {\r\n        let real_scale = Vector2 {\r\n            x: scale.x * self.size().x * 0.5,\r\n            y: scale.y * self.size().y * 0.5,\r\n        };\r\n        renderer.begin(&self.camera(), None);\r\n        renderer.draw(DrawCommand {\r\n            primitives: PrimitiveType::Texture2D {\r\n                texture_id: self.texture().clone(),\r\n                instances: vec![Transform2d {\r\n                    position: Point3 {\r\n                        x: position.x,\r\n                        y: position.y,\r\n                        z: 0.0,\r\n                    },\r\n                    scale: real_scale,\r\n                    rotation_radians: Rad(rotation_radians),\r\n                }],\r\n                flip_uv_y: true,\r\n                multiply_color: wgpu::Color {\r\n                    r: 1.0,\r\n                    g: 1.0,\r\n                    b: 1.0,\r\n                    a: opacity as f64,\r\n                },\r\n            },\r\n            draw_mode: DrawMode::Single,\r\n            additional_data: OptionalDrawData::default(),\r\n        });\r\n        renderer.end_on_texture(output);\r\n    }\r\n\r\n    pub fn camera(&self) -> Camera2d {\r\n        let half_w = self.size().x * 0.5;\r\n        let half_h = self.size().y * 0.5;\r\n        Camera2d::new(-0.01, 1000.0, [-half_w, half_w, half_h, -half_h])\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/image_editor/src/image_editor/layers/bitmap_layer.rs b/image_editor/src/image_editor/layers/bitmap_layer.rs
--- a/image_editor/src/image_editor/layers/bitmap_layer.rs	(revision ff7293a213d38a846165f08c5adac7ae94ee7857)
+++ b/image_editor/src/image_editor/layers/bitmap_layer.rs	(date 1665950715522)
@@ -7,6 +7,7 @@
     },
     Camera2d, Framework, MeshInstance2D, Texture2dConfiguration, Transform2d,
 };
+use framework::framework::ShaderId;
 
 pub struct BitmapLayerConfiguration {
     pub label: String,
@@ -84,6 +85,7 @@
         rotation_radians: f32,
         opacity: f32,
         output: &TextureId,
+        shader_to_use: Option<ShaderId>
     ) {
         let real_scale = Vector2 {
             x: scale.x * self.size().x * 0.5,
@@ -111,7 +113,7 @@
                 },
             },
             draw_mode: DrawMode::Single,
-            additional_data: OptionalDrawData::default(),
+            additional_data: OptionalDrawData::just_shader(shader_to_use),
         });
         renderer.end_on_texture(output);
     }
Index: app/src/tools/brush_engine/brush_fragment.wgsl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//@include :common_definitions\n//@include :2d_definitions\n\n@group(2) @binding(0) var diffuse: texture_2d<f32>;\n@group(2) @binding(1) var s_diffuse: sampler;\n\n@fragment\nfn fragment(in: FragmentInput) -> @location(0) vec4<f32> {\n    return textureSample(diffuse, s_diffuse, in.tex_uv).a * in.multiply_color;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/tools/brush_engine/brush_fragment.wgsl b/app/src/tools/brush_engine/brush_fragment.wgsl
--- a/app/src/tools/brush_engine/brush_fragment.wgsl	(revision ff7293a213d38a846165f08c5adac7ae94ee7857)
+++ b/app/src/tools/brush_engine/brush_fragment.wgsl	(date 1665950400006)
@@ -1,5 +1,6 @@
 //@include :common_definitions
 //@include :2d_definitions
+//@include :blend_modes
 
 @group(2) @binding(0) var diffuse: texture_2d<f32>;
 @group(2) @binding(1) var s_diffuse: sampler;
Index: image_editor/src/image_editor/mod.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>pub mod document;\r\npub mod image_editor;\r\npub mod image_editor_event;\r\npub mod layers;\r\n\r\npub use image_editor::ImageEditor;\r\npub use image_editor::LayerConstructionInfo;\r\npub use image_editor_event::ImageEditorEvent;\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/image_editor/src/image_editor/mod.rs b/image_editor/src/image_editor/mod.rs
--- a/image_editor/src/image_editor/mod.rs	(revision ff7293a213d38a846165f08c5adac7ae94ee7857)
+++ b/image_editor/src/image_editor/mod.rs	(date 1665953118114)
@@ -2,6 +2,7 @@
 pub mod image_editor;
 pub mod image_editor_event;
 pub mod layers;
+pub mod blend_settings;
 
 pub use image_editor::ImageEditor;
 pub use image_editor::LayerConstructionInfo;
Index: image_editor/src/image_editor/image_editor.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use cgmath::{ElementWise, Point2};\nuse framework::framework::ShaderId;\nuse framework::renderer::draw_command::{DrawCommand, DrawMode, OptionalDrawData, PrimitiveType};\nuse framework::renderer::renderer::Renderer;\nuse framework::scene::Camera2d;\nuse framework::shader::ShaderCreationInfo;\nuse framework::{Framework, Transform2d};\nuse wgpu::{TextureFormat, TextureView};\n\nuse crate::document::DocumentCreationInfo;\n\nuse super::{\n    document::Document,\n    layers::{BitmapLayer, Layer, LayerIndex},\n};\n\n#[derive(Default)]\npub struct LayerConstructionInfo {\n    pub initial_color: [f32; 4],\n    pub name: String,\n    pub width: u32,\n    pub height: u32,\n}\n\npub struct ImageEditor<'framework> {\n    framework: &'framework Framework,\n    pan_camera: Camera2d,\n\n    document: Document<'framework>,\n    final_present_shader: ShaderId,\n}\nimpl<'framework> ImageEditor<'framework> {\n    pub fn new(framework: &'framework Framework, initial_window_bounds: &[f32; 2]) -> Self {\n        let test_width = 1800;\n        let test_height = 1024;\n        let test_document = Document::new(\n            DocumentCreationInfo {\n                width: test_width,\n                height: test_height,\n                first_layer_color: [0.0, 0.0, 0.0, 1.0],\n            },\n            framework,\n        );\n        let left_right_top_bottom = [\n            -initial_window_bounds[0] * 0.5,\n            initial_window_bounds[0] * 0.5,\n            initial_window_bounds[1] * 0.5,\n            -initial_window_bounds[1] * 0.5,\n        ];\n        let pan_camera = Camera2d::new(-0.1, 1000.0, left_right_top_bottom);\n        let initial_camera_scale = if initial_window_bounds[0] > initial_window_bounds[1] {\n            test_document.outer_size().x / initial_window_bounds[0]\n        } else {\n            test_document.outer_size().y / initial_window_bounds[1]\n        } * 1.5;\n\n        let final_present_shader_info =\n            ShaderCreationInfo::using_default_vertex_fragment(framework)\n                .with_output_format(TextureFormat::Bgra8UnormSrgb);\n        let final_present_shader = framework.create_shader(final_present_shader_info);\n        println!(\"Initial scale: {initial_camera_scale}\");\n        //pan_camera.set_scale(initial_camera_scale);\n        ImageEditor {\n            framework,\n            pan_camera,\n            document: test_document,\n            final_present_shader,\n        }\n    }\n\n    pub fn framework(&'framework self) -> &'framework Framework {\n        self.framework\n    }\n\n    pub fn document(&self) -> &Document {\n        &self.document\n    }\n\n    pub fn export_current_image(&mut self) {\n        let file_path = rfd::FileDialog::new()\n            .add_filter(\"PNG Image\", &[\"png\"])\n            .add_filter(\"JPG Image\", &[\"jpg\", \"jpeg\"])\n            .add_filter(\"Bitmap\", &[\"bmp\"])\n            .set_title(\"Save image\")\n            .save_file();\n        if let Some(file_path) = file_path {\n            let image = self.get_full_image_bytes();\n            if let Err(e) = image.save(file_path) {\n                log::error!(\"While saving image: {e}\");\n            };\n        }\n    }\n\n    pub fn mutate_document<F: FnMut(&mut Document)>(&mut self, mut mutate_fn: F) {\n        mutate_fn(&mut self.document);\n    }\n\n    pub fn add_layer_to_document(&mut self, config: LayerConstructionInfo) {\n        self.document.add_layer(self.framework, config);\n    }\n\n    pub fn select_new_layer(&mut self, layer_idx: LayerIndex) {\n        self.document.select_layer(layer_idx);\n    }\n\n    pub fn delete_layer(&mut self, layer_idx: LayerIndex) {\n        self.document.delete_layer(layer_idx);\n    }\n\n    pub fn on_resize(&mut self, new_bounds: [f32; 4]) {\n        self.pan_camera.set_new_bounds(new_bounds);\n    }\n\n    pub fn update_layers(&mut self) {\n        self.mutate_document(|d| d.update_layers());\n    }\n\n    pub fn render_document<'s, 't>(&'s mut self, renderer: &mut Renderer)\n    where\n        'framework: 't,\n    {\n        self.document.render(renderer);\n    }\n\n    pub fn render_canvas(&mut self, renderer: &mut Renderer, output_canvas: &TextureView) {\n        renderer.begin(&self.pan_camera, Some(wgpu::Color::TRANSPARENT));\n        renderer.draw(DrawCommand {\n            primitives: PrimitiveType::Texture2D {\n                texture_id: self.document.final_layer().texture().clone(),\n                instances: vec![Transform2d {\n                    scale: self.document.document_size().cast::<f32>().unwrap() * 0.5,\n                    ..Default::default()\n                }],\n                flip_uv_y: true,\n                multiply_color: wgpu::Color::WHITE,\n            },\n            draw_mode: DrawMode::Single,\n            additional_data: OptionalDrawData {\n                additional_vertex_buffers: vec![],\n                additional_bindable_resource: vec![],\n                shader: Some(self.final_present_shader.clone()),\n            },\n        });\n        renderer.end(output_canvas);\n    }\n\n    pub fn get_full_image_texture(&self) -> &BitmapLayer {\n        &self.document().final_layer()\n    }\n\n    pub fn get_full_image_bytes(&mut self) -> image::DynamicImage {\n        self.document().final_image_bytes()\n    }\n\n    pub fn pan_camera(&mut self, delta: cgmath::Vector2<f32>) {\n        let half_outer_size = self\n            .document\n            .document_size()\n            .cast::<f32>()\n            .expect(\"Somehow this cast failed\")\n            .mul_element_wise(1.5);\n\n        let mut new_position = self.pan_camera.position() + delta;\n        new_position.x = new_position.x.clamp(-half_outer_size.x, half_outer_size.x);\n        new_position.y = new_position.y.clamp(-half_outer_size.y, half_outer_size.y);\n        self.pan_camera.set_position(new_position);\n    }\n\n    pub fn scale_view(&mut self, delta: f32) {\n        const SCALE_SPEED: f32 = 100.0; // TODO: Make this customizable\n        self.pan_camera.scale(delta * SCALE_SPEED);\n    }\n\n    // Transforms according to current camera position and current layer transform\n    pub fn transform_point_into_pixel_position(\n        &self,\n        point_normalized: Point2<f32>,\n    ) -> Option<Point2<f32>> {\n        let position_into_layer = self.camera().ndc_into_world(point_normalized);\n        Some(position_into_layer)\n    }\n\n    pub fn selected_layer(&self) -> &Layer {\n        self.document.current_layer()\n    }\n\n    pub fn camera(&self) -> &Camera2d {\n        &self.pan_camera\n    }\n    pub fn camera_mut(&mut self) -> &mut Camera2d {\n        &mut self.pan_camera\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/image_editor/src/image_editor/image_editor.rs b/image_editor/src/image_editor/image_editor.rs
--- a/image_editor/src/image_editor/image_editor.rs	(revision ff7293a213d38a846165f08c5adac7ae94ee7857)
+++ b/image_editor/src/image_editor/image_editor.rs	(date 1665953846362)
@@ -1,10 +1,10 @@
-use cgmath::{ElementWise, Point2};
-use framework::framework::ShaderId;
+use cgmath::{ElementWise, Point2, Vector4};
+use framework::framework::{BufferId, ShaderId};
 use framework::renderer::draw_command::{DrawCommand, DrawMode, OptionalDrawData, PrimitiveType};
 use framework::renderer::renderer::Renderer;
 use framework::scene::Camera2d;
-use framework::shader::ShaderCreationInfo;
-use framework::{Framework, Transform2d};
+use framework::shader::{BindElement, ShaderCreationInfo};
+use framework::{BufferConfiguration, Framework, Transform2d};
 use wgpu::{TextureFormat, TextureView};
 
 use crate::document::DocumentCreationInfo;
@@ -25,10 +25,12 @@
 pub struct ImageEditor<'framework> {
     framework: &'framework Framework,
     pan_camera: Camera2d,
+    layer_draw_shader: ShaderId,
 
     document: Document<'framework>,
     final_present_shader: ShaderId,
 }
+
 impl<'framework> ImageEditor<'framework> {
     pub fn new(framework: &'framework Framework, initial_window_bounds: &[f32; 2]) -> Self {
         let test_width = 1800;
@@ -60,11 +62,15 @@
         let final_present_shader = framework.create_shader(final_present_shader_info);
         println!("Initial scale: {initial_camera_scale}");
         //pan_camera.set_scale(initial_camera_scale);
+
+        let layer_draw_shader = framework.shader_compiler.compile_into_shader_description("Layer draw shader", include_str!("layers/layer_fragment.wgsl")).unwrap();
+        let layer_draw_shader = framework.create_shader(ShaderCreationInfo::using_default_vertex(framework, layer_draw_shader).with_bind_element(BindElement::Texture).with_bind_element(BindElement::Texture).with_bind_element(BindElement::UniformBuffer));
         ImageEditor {
             framework,
             pan_camera,
             document: test_document,
             final_present_shader,
+            layer_draw_shader,
         }
     }
 
@@ -116,10 +122,10 @@
     }
 
     pub fn render_document<'s, 't>(&'s mut self, renderer: &mut Renderer)
-    where
-        'framework: 't,
+        where
+            'framework: 't,
     {
-        self.document.render(renderer);
+        self.document.render(renderer, self.layer_draw_shader.clone());
     }
 
     pub fn render_canvas(&mut self, renderer: &mut Renderer, output_canvas: &TextureView) {
Index: app/src/blend_modes.wgsl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/blend_modes.wgsl b/app/src/blend_modes.wgsl
new file mode 100644
--- /dev/null	(date 1665952245881)
+++ b/app/src/blend_modes.wgsl	(date 1665952245881)
@@ -0,0 +1,15 @@
+fn blend_normal(bottom: vec4<f32>,  top: vec4<f32>) -> vec4<f32> {
+    // Over operator
+    let a = top.a + bottom.a * (1.0 - top.a);
+    return (bottom * bottom.a + top * top.a) / a;
+}
+
+let BLEND_NORMAL: i32 = 0;
+
+fn blend_mode(mode: i32, bottom: vec4<f32>,  top: vec4<f32>) -> vec4<f32> {
+    if (mode == BLEND_NORMAL) {
+        return blend_normal(bottom, top);
+    }
+    
+    return vec4<f32>(0.9, 0.0, 0.3, 1.0);    
+}
\ No newline at end of file
Index: image_editor/src/image_editor/blend_settings.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/image_editor/src/image_editor/blend_settings.rs b/image_editor/src/image_editor/blend_settings.rs
new file mode 100644
--- /dev/null	(date 1665953727052)
+++ b/image_editor/src/image_editor/blend_settings.rs	(date 1665953727052)
@@ -0,0 +1,31 @@
+use cgmath::Vector4;
+
+pub struct BlendSettings {
+    blend_mode: i32,
+    // x, y, w, h
+    source_rect: Vector4<f32>,
+    dest_rect: Vector4<f32>
+}
+
+#[repr(C)]
+#[derive(Clone, Copy)]
+pub struct BlendSettingsUniform {
+    blend_mode: i32, padding: [f32; 3],
+    // x, y, w, h
+    source_rect: Vector4<f32>,
+    dest_rect: Vector4<f32>
+}
+
+unsafe impl bytemuck::Zeroable for BlendSettingsUniform {}
+unsafe impl bytemuck::Pod for BlendSettingsUniform { }
+
+impl From<BlendSettings> for BlendSettingsUniform {
+    fn from(settings: BlendSettings) -> Self {
+        Self {
+            blend_mode: settings.blend_mode,
+            padding: [0.0; 3],
+            source_rect: settings.source_rect,
+            dest_rect: settings.dest_rect,
+        }
+    }
+}
\ No newline at end of file
Index: framework/src/shader/shader.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use wgpu::{\n    BindGroupLayout, BindGroupLayoutDescriptor, BlendState, ColorTargetState, FragmentState,\n    RenderPipeline, ShaderModule, ShaderModuleDescriptor, TextureFormat, VertexBufferLayout,\n    VertexState,\n};\n\nuse crate::{Buffer, Framework, Mesh, MeshInstance2D, Texture2d};\n\npub trait ShaderLayout {\n    fn layout() -> VertexBufferLayout<'static>;\n}\n\npub enum BindElement {\n    UniformBuffer,\n    Texture,\n    None,\n}\n\npub struct ShaderCreationInfo<'a> {\n    vertex_module: ShaderModule,\n    fragment_module: ShaderModule,\n    output_format: Option<TextureFormat>,\n    bind_elements: Vec<BindElement>,\n    blend_state: Option<BlendState>,\n    layouts: Vec<VertexBufferLayout<'a>>,\n}\n\nimpl<'a> ShaderCreationInfo<'a> {\n    pub fn using_default_vertex_instanced(\n        framework: &Framework,\n        fragment: ShaderModuleDescriptor,\n    ) -> Self {\n        let default_vertex_instanced = framework\n            .shader_compiler\n            .compile_into_shader_description(\n                \"Default Instanced Vertex Shader\",\n                include_str!(\"default_shaders/default_vertex_instanced.wgsl\"),\n            )\n            .unwrap();\n        let default_vertex_instanced = framework\n            .device\n            .create_shader_module(default_vertex_instanced);\n\n        let fragment_module = framework.device.create_shader_module(fragment);\n        Self {\n            vertex_module: default_vertex_instanced,\n            fragment_module,\n            output_format: None,\n            bind_elements: vec![],\n            blend_state: None,\n            layouts: vec![],\n        }\n        .with_layout::<Mesh>()\n        .with_layout::<MeshInstance2D>()\n        .with_bind_element(BindElement::UniformBuffer) // 0 camera info buffer\n        .with_bind_element(BindElement::None) // 1 is unused, for compat with default fragment shader\n    }\n    pub fn using_default_vertex(framework: &Framework, fragment: ShaderModuleDescriptor) -> Self {\n        let default_vertex = framework\n            .shader_compiler\n            .compile_into_shader_description(\n                \"Default Vertex Shader\",\n                include_str!(\"default_shaders/default_vertex.wgsl\"),\n            )\n            .unwrap();\n        let default_vertex = framework.device.create_shader_module(default_vertex);\n        let fragment_module = framework.device.create_shader_module(fragment);\n        Self {\n            vertex_module: default_vertex,\n            fragment_module,\n            output_format: None,\n            bind_elements: vec![],\n            blend_state: None,\n            layouts: vec![],\n        }\n        .with_layout::<Mesh>()\n        .with_bind_element(BindElement::UniformBuffer) // 0 mesh info buffer\n        .with_bind_element(BindElement::UniformBuffer) // 1 camera info buffer\n    }\n    pub fn using_default_vertex_fragment(framework: &Framework) -> Self {\n        let default_fragment = framework\n            .shader_compiler\n            .compile_into_shader_description(\n                \"Default Fragment Shader\",\n                include_str!(\"default_shaders/default_fragment.wgsl\"),\n            )\n            .unwrap();\n        ShaderCreationInfo::using_default_vertex(framework, default_fragment)\n            .with_bind_element(BindElement::Texture) // 2: diffuse texture + sampler\n    }\n    pub fn using_default_vertex_fragment_instanced(framework: &Framework) -> Self {\n        let default_fragment = framework\n            .shader_compiler\n            .compile_into_shader_description(\n                \"Default Fragment Shader\",\n                include_str!(\"default_shaders/default_fragment.wgsl\"),\n            )\n            .unwrap();\n        ShaderCreationInfo::using_default_vertex_instanced(framework, default_fragment)\n            .with_bind_element(BindElement::Texture) // 2: texture + sampler\n    }\n\n    pub fn with_bind_element(mut self, element: BindElement) -> Self {\n        self.bind_elements.push(element);\n        self\n    }\n    pub fn with_layout<T: ShaderLayout>(mut self) -> Self {\n        self.layouts.push(T::layout());\n        self\n    }\n    pub fn with_blend_state(mut self, blend_state: BlendState) -> Self {\n        self.blend_state = Some(blend_state);\n        self\n    }\n    pub fn with_output_format(mut self, format: wgpu::TextureFormat) -> Self {\n        self.output_format = Some(format);\n        self\n    }\n}\n\npub struct Shader {\n    pub(crate) render_pipeline: RenderPipeline,\n}\n\nimpl Shader {\n    pub fn reserved_buffer_count() -> u32 {\n        5\n    }\n    pub(crate) fn new(framework: &Framework, info: ShaderCreationInfo) -> Self {\n        let bind_group_layouts =\n            Shader::bind_group_layouts_from_bind_elements(framework, &info.bind_elements);\n        let bind_group_layouts: Vec<&BindGroupLayout> =\n            bind_group_layouts.iter().map(|g| g).collect();\n        let render_pipeline_layout =\n            framework\n                .device\n                .create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {\n                    label: Some(\"Shader pipeline layout\"),\n                    bind_group_layouts: bind_group_layouts.as_slice(),\n                    push_constant_ranges: &[],\n                });\n\n        let render_pipeline =\n            framework\n                .device\n                .create_render_pipeline(&wgpu::RenderPipelineDescriptor {\n                    label: Some(\"StampingEngine pipeline\"),\n                    layout: Some(&render_pipeline_layout),\n                    depth_stencil: None,\n                    vertex: VertexState {\n                        module: &info.vertex_module,\n                        entry_point: \"vertex\",\n                        buffers: &info.layouts.as_slice(),\n                    },\n                    fragment: Some(FragmentState {\n                        module: &info.fragment_module,\n                        entry_point: \"fragment\",\n                        targets: &[Some(ColorTargetState {\n                            format: info.output_format.unwrap_or(TextureFormat::Rgba8UnormSrgb),\n                            blend: Some(\n                                info.blend_state\n                                    .unwrap_or(BlendState::PREMULTIPLIED_ALPHA_BLENDING),\n                            ),\n                            write_mask: wgpu::ColorWrites::ALL,\n                        })],\n                    }),\n                    multisample: wgpu::MultisampleState {\n                        count: 1,\n                        mask: !0,\n                        alpha_to_coverage_enabled: false,\n                    },\n                    multiview: None,\n                    primitive: wgpu::PrimitiveState {\n                        topology: wgpu::PrimitiveTopology::TriangleList,\n                        strip_index_format: None,\n                        front_face: wgpu::FrontFace::Cw,\n                        conservative: false,\n                        cull_mode: Some(wgpu::Face::Back),\n                        polygon_mode: wgpu::PolygonMode::Fill,\n                        unclipped_depth: false,\n                    },\n                });\n        Self { render_pipeline }\n    }\n\n    fn bind_group_layouts_from_bind_elements(\n        framework: &Framework,\n        elements: &Vec<BindElement>,\n    ) -> Vec<BindGroupLayout> {\n        elements\n            .iter()\n            .map(|e| match e {\n                BindElement::UniformBuffer => Buffer::bind_group_layout(framework),\n                BindElement::Texture => Texture2d::bind_group_layout(framework),\n                BindElement::None => {\n                    framework\n                        .device\n                        .create_bind_group_layout(&BindGroupLayoutDescriptor {\n                            label: None,\n                            entries: &[],\n                        })\n                }\n            })\n            .collect()\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/framework/src/shader/shader.rs b/framework/src/shader/shader.rs
--- a/framework/src/shader/shader.rs	(revision ff7293a213d38a846165f08c5adac7ae94ee7857)
+++ b/framework/src/shader/shader.rs	(date 1665951266728)
@@ -144,7 +144,7 @@
             framework
                 .device
                 .create_render_pipeline(&wgpu::RenderPipelineDescriptor {
-                    label: Some("StampingEngine pipeline"),
+                    label: Some("Shader pipeline"),
                     layout: Some(&render_pipeline_layout),
                     depth_stencil: None,
                     vertex: VertexState {
Index: framework/src/renderer/draw_command.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::{\n    framework::{BufferId, ShaderId, TextureId},\n    Transform2d,\n};\n\npub enum DrawMode {\n    // The shader used supports instancing: all the instance data passed in the draw call\n    // will be stored in an instance buffer\n    Instanced,\n\n    // The instances will be drawn in separated render passes\n    Single,\n}\n\n#[derive(Default)]\npub enum PrimitiveType {\n    #[default]\n    Noop,\n    Texture2D {\n        texture_id: TextureId,\n        instances: Vec<Transform2d>,\n        flip_uv_y: bool,\n        multiply_color: wgpu::Color,\n    },\n}\n\npub enum BindableResource {\n    UniformBuffer(BufferId),\n    Texture(TextureId),\n}\n\n#[derive(Default)]\npub struct OptionalDrawData {\n    pub additional_vertex_buffers: Vec<BufferId>,\n    pub additional_bindable_resource: Vec<BindableResource>,\n\n    // If none, an appropriate shader will be picked by the renderer based on the draw_type\n    pub shader: Option<ShaderId>,\n}\n\npub struct DrawCommand {\n    pub primitives: PrimitiveType,\n    pub draw_mode: DrawMode,\n    pub additional_data: OptionalDrawData,\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/framework/src/renderer/draw_command.rs b/framework/src/renderer/draw_command.rs
--- a/framework/src/renderer/draw_command.rs	(revision ff7293a213d38a846165f08c5adac7ae94ee7857)
+++ b/framework/src/renderer/draw_command.rs	(date 1665950687811)
@@ -1,3 +1,4 @@
+use std::default;
 use crate::{
     framework::{BufferId, ShaderId, TextureId},
     Transform2d,
@@ -38,6 +39,15 @@
     pub shader: Option<ShaderId>,
 }
 
+impl OptionalDrawData {
+    pub fn just_shader(shader: Option<ShaderId>) -> Self {
+        Self {
+            shader,
+            ..Default::default()
+        }
+    }
+}
+
 pub struct DrawCommand {
     pub primitives: PrimitiveType,
     pub draw_mode: DrawMode,
